
#include <Arduino.h>
//#include <TelnetSpy.h>
#include <ArduinoOTA.h>
#include <Serial9b.h>
#include <SoftwareSerial.h>
#include <hacomponent.h>
#include <ETH.h>

#include "secrets.h"
#include "mate.h"
#include "mqtt.h"
#include "mate-collector.h"

const char* ntpServer1 = "pool.ntp.org";

// Debugging is available at port 23 (raw connection)
//static TelnetSpy telnet;
Stream& Debug = Serial;//telnet;

// Generated by version.py
extern const char* GEN_BUILD_VERSION;

boolean g_failsafe = false;

// The ESP32 hardware UARTs unfortunately don't support 9-bit data,
// so we are forced to use a software serial implementation.
SoftwareSerial Serial9b;

WiFiClient                  wifi;
PubSubClient                Mqtt::client(wifi);
ComponentContext            Mqtt::context(Mqtt::client);
HAAvailabilityComponent     availability(Mqtt::context);
MatePubContext              mate_context(Mqtt::client);

// TTGO-T1
//#define MATE_TX (19)
//#define MATE_RX (23)

// WESP32
#define MATE_TX (5)
#define MATE_RX (18)


void fault()
{
    Debug.println("HALTED.");
    while (true) { }
}


void printWiFiStatus(wl_status_t status) {
    switch (status) {
        case WL_CONNECTED:
            Debug.println("Connected!");
            break;
        case WL_NO_SSID_AVAIL:
            // Bad SSID or AP not present
            Debug.println("No SSID Available");
            break;
        case WL_CONNECT_FAILED:
            // Bad password
            Debug.println("Failed to connect");
            break;
        case WL_IDLE_STATUS:
            Debug.println("Station Idle");
            break;
        case WL_CONNECTION_LOST:
            Debug.println("Connection lost");
            break;
        default:
            Debug.println(status, HEX);
    }
}

#ifdef MODE_WIFI
void connectWiFi()
{
    wl_status_t result;

    WiFi.persistent(false);

    while (WiFi.status() != WL_CONNECTED) {
        Debug.println();

        WiFi.mode(WIFI_STA);
        WiFi.config(INADDR_NONE, INADDR_NONE, INADDR_NONE, INADDR_NONE);
        WiFi.setHostname(secrets::device_name);
        WiFi.begin(secrets::wifi_ssid, secrets::wifi_pw);
        Debug.print("Connecting to SSID: "); Debug.println(secrets::wifi_ssid);

        result = (wl_status_t)WiFi.waitForConnectResult();
        if (result != WL_CONNECTED) {
            Debug.print("Error connecting: "); printWiFiStatus(result);

            Debug.println("Diagnostics:");
            WiFi.printDiag(Serial);
            Debug.println();

            delay(1000);
        }
    }

    Debug.print("IP address: ");
    Debug.println(WiFi.localIP());
}
#endif

#ifdef MODE_ETH
void connectLan()
{
    Debug.println();
    Debug.println("Connecting to LAN...");

    //ETH.config(INADDR_NONE, INADDR_NONE, INADDR_NONE, INADDR_NONE);
    ETH.begin();
    ETH.setHostname(secrets::device_name);

    while (!ETH.linkUp())
        continue;
    while (static_cast<uint32_t>(ETH.localIP()) == 0)
        continue;
    
    Debug.print("IP address: ");
    Debug.println(ETH.localIP());

    Debug.print("Gateway:    ");
    Debug.println(ETH.gatewayIP());
}
#endif

void connectNtp()
{
    configTime(0, 0, ntpServer1);

    Debug.println("Current time (UTC):");

    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        Serial.println(&timeinfo, "%Y-%m-%d %H:%M:%S");
    }
    else {
        Debug.println("<error>");
    }
}

void publish() {
    // Publish entities to Home-Assistant
    availability.PublishConfig();
    availability.Connect();
}

void setup()
{
    // // Debugging
    // telnet.setWelcomeMsg("Connected!");
    // telnet.setCallbackOnConnect([] {
    //     Serial.print("Telnet connected");
    // });
    // telnet.setCallbackOnDisconnect([] {
    //     Serial.print("Telnet disconnected");
    // });
    // telnet.setDebugOutput(false);
    // telnet.begin(serial_baud);

    Serial.begin(115200);
    //Serial1.begin(115200);

    Debug.println();

    Debug.print("FW Version: ");
    Debug.println(GEN_BUILD_VERSION);

    Debug.print("Chip:       ");
    Debug.println(ESP.getChipModel());

    Debug.print("SDK:        ");
    Debug.println(ESP.getSdkVersion());

    Debug.print("Name:       ");
    Debug.println(secrets::friendly_name);

    Debug.print("MAC:        ");
    Debug.println(WiFi.macAddress());

    // TODO: Equivalent for ESP32?
    // // Detect if previous reset was due to an Exception,
    // // so we can go into a failsafe mode with only WiFi + OTA.
    // auto rst = ESP.getResetInfoPtr();
    // if (rst->reason == 2) { // 2: EXCEPTION
    //     Debug.println();
    //     Debug.println("!! PREVIOUS RESET WAS CAUSED BY EXCEPTION !!");
    //     g_failsafe = true;
    // }

/// Initialization ///

    Serial9b.begin(9600, MATE_RX, MATE_TX, SWSERIAL_9N1, false);
    Serial9b.enableRx(true);
    Serial9b.enableTx(true);
    if (!Serial9b) {
        Debug.println("ERROR: Invalid Serial9b Configuration");
        fault();
    }

    // Copy config to the MQTT context
    Mqtt::context.device_name   = secrets::device_name;
    Mqtt::context.friendly_name = secrets::friendly_name;
    Mqtt::context.fw_version    = GEN_BUILD_VERSION;
    Mqtt::context.manufacturer  = "ViscTronics";
    Mqtt::context.model         = "ESP-MATE Gateway";

    mate_context.device_name    = secrets::device_name;
    mate_context.prefix         = secrets::device_name; // MQTT topic prefix for publishing MATE data

    // Initialize all HA components
    // IMPORTANT: Mqtt::context must be initialized first!
    HACompItem::InitializeAll();

/// Initialization done, connect to network ///

    // Connect to network (blocks until connection formed)
#ifdef MODE_WIFI
    connectWiFi();
    Debug.println();
#endif
#ifdef MODE_ETH
    connectLan();
    Debug.println();
#endif

    // Configure NTP server (GMT timezone)
    connectNtp();
    Debug.println();

    // Connect to MQTT (blocks until connection formed)
    Mqtt::setup(secrets::mqtt_server, secrets::mqtt_port);
    Mqtt::connect();

    publish();
    Debug.println();

/// Connected to network, set up devices ///

    // Discover MATE devices
    MateAggregator::setup();
    Debug.println();
}

void idle_loop() {
    //Led::Process();
    ArduinoOTA.handle();
    yield();
}

void loop() {
#ifdef MODE_ETH
    // Only process network tasks if ethernet is connected.
    if (ETH.linkUp())
#endif
    {
        //telnet.handle();
        ArduinoOTA.handle();

        bool reconnected = Mqtt::process();
        if (reconnected) {
            publish(); // Re-publish entity config
            Debug.println();
        }
    }

#ifdef MODE_WIFI
    if (WiFi.status() != WL_CONNECTED) {
        Debug.println("Disconnected from WiFi");
        connectWiFi();
        Debug.println();
    }
#endif

    MateAggregator::loop();

    //if (!OTA::is_updating && !g_failsafe) {
    //   bool reconnected = Mqtt::Process(config);
    //   if (reconnected) {
    //   publish();
    //   SetAppStatus(AppStatus::Sensing);
    //   }
    //}
}

void __assert(const char * a, int b, const char * c) {
    Debug.println("ASSERT");
    Debug.println(a);
    Debug.println(b);
    Debug.println(c);
    fault();
    while(true) { }
}

void __assert_func(const char * src_path, int line_no, const char * func_name, const char * expression) {
    // ASSERT: collector != nullptr (in src\mate.cpp:128)
    Debug.print("ASSERT: ");
    Debug.print(expression);
    Debug.print(" (in ");
    Debug.print(src_path);
    Debug.print(":");
    Debug.print(line_no);
    Debug.println(")");
    fault();
    while(true) { }
}
