
#include <Arduino.h>
#include <WiFiClientSecure.h>
//#include <TelnetSpy.h>
#include <ArduinoOTA.h>
#include <Serial9b.h>
#include <SoftwareSerial.h>
#include <hacomponent.h>
#include <ETH.h>

#include "secrets.h"
#include "mate.h"
#include "mqtt.h"
#include "mate-collector.h"

const char* ntpServer1 = "pool.ntp.org";

// Debugging is available at port 23 (raw connection)
//static TelnetSpy telnet;
Stream& Debug = Serial;//telnet;

// Generated by version.py
extern const char* GEN_BUILD_VERSION;

boolean g_failsafe = false;
static boolean m_ota_initialized = false;

// The ESP32 hardware UARTs unfortunately don't support 9-bit data,
// so we are forced to use a software serial implementation.
SoftwareSerial Serial9b;

//WiFiClient                  net;
WiFiClientSecure            net;
PubSubClient                Mqtt::client(net);
ComponentContext            Mqtt::context(Mqtt::client);
HAAvailabilityComponent     availability(Mqtt::context);
MatePubContext              mate_context(Mqtt::client);

// TTGO-T1
//#define MATE_TX (19)
//#define MATE_RX (23)

// WESP32
#define MATE_TX (5)
#define MATE_RX (18)


void fault()
{
    Debug.println("HALTED.");
    if (m_ota_initialized) {
        while (true) {
            ArduinoOTA.handle();
        }
    } else {
        while (true) { }
    }
}


void printWiFiStatus(wl_status_t status) {
    switch (status) {
        case WL_CONNECTED:
            Debug.println("Connected!");
            break;
        case WL_NO_SSID_AVAIL:
            // Bad SSID or AP not present
            Debug.println("No SSID Available");
            break;
        case WL_CONNECT_FAILED:
            // Bad password
            Debug.println("Failed to connect");
            break;
        case WL_IDLE_STATUS:
            Debug.println("Station Idle");
            break;
        case WL_CONNECTION_LOST:
            Debug.println("Connection lost");
            break;
        default:
            Debug.println(status, HEX);
    }
}

#ifdef MODE_WIFI
void connectWiFi()
{
    wl_status_t result;

    WiFi.persistent(false);

    while (WiFi.status() != WL_CONNECTED) {
        Debug.println();

        WiFi.mode(WIFI_STA);
        WiFi.config(INADDR_NONE, INADDR_NONE, INADDR_NONE, INADDR_NONE);
        WiFi.setHostname(secrets::device_name);
        WiFi.begin(secrets::wifi_ssid, secrets::wifi_pw);
        Debug.print("Connecting to SSID: "); Debug.println(secrets::wifi_ssid);

        result = (wl_status_t)WiFi.waitForConnectResult();
        if (result != WL_CONNECTED) {
            Debug.print("Error connecting: "); printWiFiStatus(result);

            Debug.println("Diagnostics:");
            WiFi.printDiag(Serial);
            Debug.println();

            delay(1000);
        }
    }

    Debug.print("IP address: ");
    Debug.println(WiFi.localIP());
}
#endif

#ifdef MODE_ETH
void connectLan()
{
    Debug.println();
    Debug.println("Connecting to LAN...");

    //ETH.config(INADDR_NONE, INADDR_NONE, INADDR_NONE, INADDR_NONE);
    ETH.begin();
    ETH.setHostname(secrets::device_name);

    while (!ETH.linkUp())
        continue;
    while (static_cast<uint32_t>(ETH.localIP()) == 0)
        continue;
    
    Debug.print("IP address: ");
    Debug.println(ETH.localIP());

    Debug.print("Gateway:    ");
    Debug.println(ETH.gatewayIP());
}
#endif

void connectNtp()
{
    configTime(0, 0, ntpServer1);

    Debug.println("Current time (UTC):");

    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        Serial.println(&timeinfo, "%Y-%m-%d %H:%M:%S");
    }
    else {
        Debug.println("<error>");
    }
}

void setupOTA()
{
    ArduinoOTA.setHostname(secrets::device_name);

    ArduinoOTA.onStart([]() {
        //is_updating = true;

        // Set system to a safe state
        //setup_platform();

        //SetAppStatus(AppStatus::Programming);

        Debug.println("OTA Initiated");
        Debug.println("Flashing...");
    });

    ArduinoOTA.onEnd([]() {
        Debug.println("\nOTA Done!");
        //is_updating = false;

        //Led::Clear();
        //SetAppStatus(AppStatus::ProgrammingSuccess);
        delay(1000);

        // WARNING:
        // OTA may hang here if you have just flashed via UART.
        // To avoid this, please reset the ESP after flashing directly.
    });

    ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
        // static int last_x = 0;
        // int x = (progress / (total / 20));
        // if (x != last_x) {
        // 	Debug.print("#");
        // 	last_x = x;
        // }
        // if (progress == total) {
        // 	Debug.println();
        // }

        //Led::SetProgress(Colors::Blue, (progress * 100) / total);
    });

    ArduinoOTA.onError([](ota_error_t error) {
        Debug.println();
        Debug.printf("Error[%u]: ", error);

        //Led::Clear();
        //SetAppStatus(AppStatus::Faulted);

        if (error == OTA_AUTH_ERROR)            Debug.println("Auth Failed");
        else if (error == OTA_BEGIN_ERROR)      Debug.println("Begin Failed");
        else if (error == OTA_CONNECT_ERROR)    Debug.println("Connect Failed");
        else if (error == OTA_RECEIVE_ERROR)    Debug.println("Receive Failed");
        else if (error == OTA_END_ERROR)        Debug.println("End Failed");
        //is_updating = false;

        delay(1000);
        ESP.restart();
    });

    // Enable OTA
    ArduinoOTA.begin();
    m_ota_initialized = true;
}

void publish() {
    // Publish entities to Home-Assistant
    availability.PublishConfig();
    availability.Connect();
}

void setup()
{
    Serial.begin(115200);

    Debug.println();

    Debug.print("FW Version: ");
    Debug.println(GEN_BUILD_VERSION);

    Debug.print("Chip:       ");
    Debug.println(ESP.getChipModel());

    Debug.print("SDK:        ");
    Debug.println(ESP.getSdkVersion());

    Debug.print("Name:       ");
    Debug.println(secrets::friendly_name);

    Debug.print("MAC:        ");
    Debug.println(WiFi.macAddress());

/// Initialization ///

    Serial9b.begin(9600, MATE_RX, MATE_TX, SWSERIAL_9N1, false);
    Serial9b.enableRx(true);
    Serial9b.enableTx(true);
    if (!Serial9b) {
        Debug.println("ERROR: Invalid Serial9b Configuration");
        fault();
    }

    // Copy config to the MQTT context
    Mqtt::context.device_name   = secrets::device_name;
    Mqtt::context.friendly_name = secrets::friendly_name;
    Mqtt::context.fw_version    = GEN_BUILD_VERSION;
    Mqtt::context.manufacturer  = "ViscTronics";
    Mqtt::context.model         = "ESP-MATE Gateway";

    mate_context.device_name    = secrets::device_name;
    mate_context.prefix         = secrets::device_name; // MQTT topic prefix for publishing MATE data

    // Initialize all HA components
    // IMPORTANT: Mqtt::context must be initialized first!
    HACompItem::InitializeAll();

/// Initialization done, connect to network ///

    // Connect to network (blocks until connection formed)
#ifdef MODE_WIFI
    connectWiFi();
    Debug.println();
#endif
#ifdef MODE_ETH
    connectLan();
    Debug.println();
#endif

    setupOTA();

    // Configure NTP server (GMT timezone)
    // Required before we can validate SSL
    connectNtp();
    Debug.println();

    // Set up SSL
    net.setCACert(secrets::ca_root_cert);
    //net.setInsecure();

    // Connect to MQTT (blocks until connection formed)
    Mqtt::setup(secrets::mqtt_server, secrets::mqtt_port);
    Mqtt::connect();

    publish();
    Debug.println();

/// Connected to network, set up devices ///

    // Discover MATE devices
    MateAggregator::setup();
    Debug.println();
}

void idle_loop() {
    //Led::Process();
    ArduinoOTA.handle();
    yield();
}

void loop() {
#ifdef MODE_ETH
    // Only process network tasks if ethernet is connected.
    if (ETH.linkUp())
#endif
    {
        //telnet.handle();
        ArduinoOTA.handle();

        bool reconnected = Mqtt::process();
        if (reconnected) {
            publish(); // Re-publish entity config
            Debug.println();
        }
    }

#ifdef MODE_WIFI
    if (WiFi.status() != WL_CONNECTED) {
        Debug.println("Disconnected from WiFi");
        connectWiFi();
        Debug.println();
    }
#endif

    MateAggregator::loop();
}

void __assert(const char * a, int b, const char * c) {
    Debug.println("ASSERT");
    Debug.println(a);
    Debug.println(b);
    Debug.println(c);
    fault();
    while(true) { }
}

void __assert_func(const char * src_path, int line_no, const char * func_name, const char * expression) {
    // ASSERT: collector != nullptr (in src\mate.cpp:128)
    Debug.print("ASSERT: ");
    Debug.print(expression);
    Debug.print(" (in ");
    Debug.print(src_path);
    Debug.print(":");
    Debug.print(line_no);
    Debug.println(")");
    fault();
    while(true) { }
}
